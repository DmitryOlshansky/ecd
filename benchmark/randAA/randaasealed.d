/**
An associative array implementation that uses randomized linear congruential
probing for collision resolution.  This has the advantage that, no matter
how many collisions there are in the modulus hash space, O(1) expected
lookup time is guaranteed as long as there are few collisions in full 32-
or 64-bit hash space.

Known Bugs/TODOs:

Const correctness.

Copyright (C) 2009-2011 David Simcha

License:
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
 */
import std.typecons, std.intrinsic, core.stdc.stdlib, std.traits, core.memory,
    core.exception, std.conv, std.array;

/**Exception thrown on missing keys.*/
class KeyError : Exception {
    this(string msg) {
        super(msg);
    }
}

private enum SlotState{
    empty,
    used,
    removed
}

/**
Forward range to iterate over keys or values of a RandAA.  Note that this
range is invalidated by any changes made to the underlying RandAA.
*/
struct RandAARange(alias fun, T) {
    private T data;

    // Unsigned equivalent of -1, because it gets incremented at beginning of
    // popFront().
    private size_t curIndex = size_t.max;
    private size_t _length;

    private this(ref T data) {
        // By reference to cut down to one copy and ref count overhead.
        this.data = data;
        _length = data._length + 1;
        popFront();
    }

    @property bool empty() {
        return length == 0 || curIndex >= data._flags.length;
    }

    void popFront() {
        curIndex++;
        _length--;
        if(length == 0) return;

        while(curIndex < data._flags.length &&
        data._flags[curIndex] != SlotState.used) {
            curIndex++;
        }
    }

    @property typeof(this) save() { return this; }

    @property auto front() {
        return fun(data)[curIndex];
    }

    @property size_t length() {
        return _length;
    }
}

// It's faster to store the hash if it's expensive to compute, but
// faster not to if it's cheap to compute.
private template shouldStoreHash(K) {
    enum bool shouldStoreHash = !isFloatingPoint!K && !isIntegral!K;
}

private void doFree(T)(T[] arr) {
    foreach(ref e; arr) clear(e);
    doFreeNoClear(arr);
}

private void doFreeNoClear(T)(T[] arr) {
    static if(hasIndirections!T) {
        GC.removeRange(arr.ptr);
    }

    free(cast(void*) arr.ptr);
}

private T[] newMalloc(T)(size_t size) {
    auto ptr = cast(T*) malloc(size * T.sizeof);
    if(!ptr) throw new OutOfMemoryError(__FILE__, __LINE__);
    scope(failure) free(cast(void*) ptr);

    static if(hasIndirections!T) {
        GC.addRange(ptr, size * T.sizeof);
    }

    auto arr = ptr[0..size];
    arr[] = T.init;
    return arr;
}

// Rounds num to the next larger power of two.
private size_t nextPowerOfTwo(size_t num) {
    if(std.intrinsic.bsr(num) == std.intrinsic.bsf(num)) return num;
    return 1 << std.intrinsic.bsr(num << 1);
}

/**
An associative array class that uses randomized probing and open
addressing.  K is the key type, V is the value type, storeHash
determines whether the hash of each key is stored in the array.  This
increases space requirements, but allows for faster rehashing.  By
default, the hash is stored unless the array is an array of floating point
or integer types.
 */
struct RandAA(K, V, bool storeHash = shouldStoreHash!(K)) {
private:

    static struct Payload {
        // Store keys, values in parallel arrays.  This prevents us from having
        // alignment overhead and prevents the GC from scanning values if only
        // keys have pointers, or vice-versa.
        K[] _keys;
        V[] _vals;
        ubyte[] _flags;

        static if(storeHash) {
            hash_t[] _hashes;  // For fast reindexing.
        }

        size_t _length;  // Logical size
        size_t _nDead;  // Number of elements removed.
        size_t _modulus;

        size_t _lengthDead() const pure nothrow @property @safe {
            return _length + _nDead;
        }

        ~this() {
            doFree(_keys);
            doFree(_vals);
            doFree(_flags);
            static if(storeHash) {
                doFree(_hashes);
            }
        }
    }

    alias RefCounted!(Payload, RefCountedAutoInitialize.no) Data;
    Data _data;

    // Good values for a linear congruential random number gen.  The modulus
    // is implicitly uint.max + 1 on 32-bit and ulong.max + 1 on 64-bit, 
    // meaning that we take advantage of overflow to avoid a div instruction.
    
    static if(size_t.sizeof == uint.sizeof) {
        enum mul = 1103515245U;
        enum add = 12345U;
    } else {
        enum mul = 2862933555777941757UL;
        enum add = 3037000493UL;
    }        

    // Optimized for a few special cases to avoid the virtual function call
    // to TypeInfo.getHash().
    hash_t getHash(K key) {
        static if(is(K : long) && K.sizeof <= hash_t.sizeof) {
            hash_t hash = cast(hash_t) key;
        } else static if(is(typeof(key.toHash()))) {
            hash_t hash = key.toHash();
        } else {
            hash_t hash = typeid(K).getHash(&key);
        }

        return hash;
    }

    // Find a slot to insert a given key.  Return the index of this slot.
    size_t findForInsert(K key) {
        auto hashFull = getHash(key);
        return findForInsert(key, hashFull);
    }

    static if(storeHash) {
        size_t findExisting(K key) {
            if(!initialized) return size_t.max;

            immutable hashFull = getHash(key);
            size_t pos =  hashFull & _data._modulus;
            size_t rand = hashFull + 1;

            uint flag = void;
            while(true) {
                flag = _data._flags[pos];
                if(flag == SlotState.empty ||
                (hashFull == _data._hashes[pos] && key ==
                 _data._keys[pos] && flag != SlotState.empty)) {
                    break;
                }

                rand = rand * mul + add;
                pos = (rand + hashFull) & _data._modulus;
            }
            return (flag == SlotState.used) ? pos : size_t.max;
        }

        size_t findForInsert(K key, immutable hash_t hashFull) {
            size_t pos = hashFull & _data._modulus;
            size_t rand = hashFull + 1;

            while(true) {
                if(_data._flags[pos] != SlotState.used ||
                (_data._hashes[pos] == hashFull &&
                 _data._keys[pos] == key)) {
                       break;
                }
                rand = rand * mul + add;
                pos = (rand + hashFull) & _data._modulus;
            }

            _data._hashes[pos] = hashFull;
            return pos;
        }
    } else {
        size_t findExisting(K key) {
            if(!initialized) return size_t.max;

            immutable hashFull = getHash(key);
            size_t pos =  hashFull & _data._modulus;
            size_t rand = hashFull + 1;

            uint flag = void;
            while(true) {

                flag = _data._flags[pos];
                if(flag == SlotState.empty ||
                (_data._keys[pos] == key && flag != SlotState.empty)) {
                    break;
                }

                rand = rand * mul + add;
                pos = (rand + hashFull) & _data._modulus;
            }
            return (flag == SlotState.used) ? pos : size_t.max;
        }

        size_t findForInsert(K key, immutable hash_t hashFull) {
            size_t pos = hashFull & _data._modulus;
            size_t rand = hashFull + 1;

            while(_data._flags[pos] == SlotState.used &&
            _data._keys[pos] != key) {
                rand = rand * mul + add;
                pos = (rand + hashFull) & _data._modulus;
            }

            return pos;
        }
    }

    void assignNoRehashCheck(K key, V val, hash_t hashFull) {
        size_t i = findForInsert(key, hashFull);
        finishAssign(key, val, i);
    }

    void assignNoRehashCheck(K key, V val) {
        size_t i = findForInsert(key);
        finishAssign(key, val, i);
    }

    void finishAssign(K key, V val, size_t i) {
        _data._vals[i] = val;
        immutable uint flag = _data._flags[i];
        if(flag != SlotState.used) {
            if(flag == SlotState.removed) {
                _data._nDead--;
            }
            _data._length++;
            _data._flags[i] = SlotState.used;
            _data._keys[i] = key;
        }
    }

    void resizeTable(size_t newSize)
    in {
        // The table is required to be a power of two so we can use a (cheap)
        // and instruction instead of an (expensive) mod instruction.
        assert(std.intrinsic.bsr(newSize) == std.intrinsic.bsf(newSize));
    } body {
        auto oldKeys = _data._keys;
        auto oldValues = _data._vals;
        auto oldFlags = _data._flags;
        immutable oldLength = _data._length;
        immutable oldModulus = _data._modulus;
        immutable oldDead = _data._nDead;
        _data._length = 0;
        _data._modulus = newSize - 1;
        _data._nDead = 0;

        static if(storeHash) {
            auto oldHashes = _data._hashes;
        }

        scope(success) {
            doFreeNoClear(oldKeys);
            doFreeNoClear(oldValues);
            doFreeNoClear(oldFlags);

            static if(storeHash) {
                doFreeNoClear(oldHashes);
            }
        }

        scope(failure) {
            // Put the old data back.
            _data._keys = oldKeys;
            _data._vals = oldValues;
            _data._flags = oldFlags;
            _data._length = oldLength;
            _data._modulus = oldModulus;
            _data._nDead = oldDead;

            static if(storeHash) {
                _data._hashes = oldHashes;
            }
        }

        _data._keys = newMalloc!K(newSize);
        scope(failure) doFreeNoClear(_data._keys);

        _data._vals = newMalloc!V(newSize);
        scope(failure) doFreeNoClear(_data._vals);

        _data._flags = newMalloc!ubyte(newSize);
        scope(failure) doFreeNoClear(_data._flags);

        static if(storeHash) {
            _data._hashes = newMalloc!hash_t(newSize);
            scope(failure) doFreeNoClear(_data._hashes);
        }

        foreach(i, k; oldKeys) {
            if(oldFlags[i] == SlotState.used) {
                static if(storeHash) {
                    assignNoRehashCheck(k, oldValues[i], oldHashes[i]);
                } else {
                    assignNoRehashCheck(k, oldValues[i]);
                }
            }
        }
    }

    bool initialized() @property {
        return _data.RefCounted.isInitialized();
    }

    void initialize() {
        if(!initialized) {
            _data.RefCounted.initialize();
            resizeTable(8);
        }
    }

    static K[] extractKeys(ref typeof(_data) data) {
        return data._keys;
    }

    static V[] extractVals(ref typeof(_data) data) {
        return data._vals;
    }

public:

    /**
    Constructor to reserve a pre-specified amount of space.
    */
    this(size_t size) {
        reserve(size);
    }

    ///
    void rehash() {
        immutable lengthDead = _data._lengthDead;
        // Target a load factor of 0.66.
        if(lengthDead + (lengthDead / 2) <= _data._keys.length) {
            return;
        }

        auto newSize = nextPowerOfTwo(_data._length + 1);
        if(lengthDead + (lengthDead / 2) > newSize) {
            // Can be untrue if there are a lot of deleted elements.
            newSize *= 2;
        }

        resizeTable(newSize);
    }

    /**
    The number of elements that can be in the array without triggering a
    reallocation.
    */
    size_t capacity() @property {
        if(!initialized) return 0;
        return _data._flags.length - _data._nDead;
    }

    /**
    Reserves enough space to guarantee that no reallocation will be
    necessary until (newSize - length) elements are added.
    */
    void reserve(size_t newSize) {
        if(!initialized) {
            _data.RefCounted.initialize();
        }

        if(capacity < newSize) {
            resizeTable(nextPowerOfTwo(newSize));
        }
    }

    ///
    V opIndex(K index) {
        size_t i = findExisting(index);
        if(i == size_t.max) {
            throw new KeyError("Could not find key " ~ to!string(index));
        } else {
            return _data._vals[i];
        }
    }

    ///
    V opIndexAssign(V val, K index) {
        initialize();
        rehash();
        assignNoRehashCheck(index, val);
        return val;
    }

    ///
    V opIndexOpAssign(string op)(V value, K index) {
        size_t i = findExisting(index);
        if(i == size_t.max) {
            throw new KeyError("Could not find key " ~ to!string(index));
        } else {
            mixin("_data._vals[i] " ~ op ~ "= value;");
            return _data._vals[i];
        }
    }

    ///
    V get(K index, lazy V defaultVal) {
        size_t i = findExisting(index);
        if(i == size_t.max) return defaultVal;
        return _data._vals[i];
    }

    ///
    V remove(K index) {
        size_t i = findExisting(index);
        if(i == size_t.max) {
            throw new KeyError("Could not find key " ~ to!string(index));
        } else {
            _data._length--;
            _data._nDead++;
            _data._flags[i] = SlotState.removed;
            return _data._vals[i];
        }
    }

    ///
    bool opIn_r(K index) {
        return findExisting(index) != size_t.max;
    }

    ///
    size_t length() @property {
        if(!_data.RefCounted.isInitialized) return 0;
        return _data._length;
    }

    /**
    Iterate lazily over the keys.  Note that adding or removing a key
    invalidates the range.
    */
    RandAARange!(extractKeys, Data) byKey() @property {
        initialize();
        return typeof(return)(_data);
    }

    /**
    Iterate lazily over the values.  Note that adding or removing a value
    invalidates the range.
    */
    RandAARange!(extractVals, Data) byValue() @property {
        initialize();
        return typeof(return)(_data);
    }

    /**
    Efficiently iterate over keys and values in lockstep.

    BUGS:  Escapes references because there's no way to avoid this with
           opApply.  See DMD Bug 2443.
    */
    int opApply(int delegate(ref K, ref V) dg) {
        if(!initialized) return 0;
        int res;

        foreach(i, flag; _data._flags) if(flag == SlotState.used) {
            res = dg(_data._keys[i], _data._vals[i]);
            if(res) break;
        }

        return res;
    }

    /**
    Eagerly create an array of keys.
    */
    K[] keys() @property {
        return array(byKey);
    }

    /**
    Eagerly create an array of values.
    */
    V[] values() @property {
        return array(byValue);
    }
}

import std.random, std.exception, std.stdio, std.algorithm, std.range,
    std.datetime;

// Returns a random string composed of the letters [a-z] with geometrically
// distributed length.
private string randString(real expectedLength) {
    string ret;
    real cutoff = 1.0L / expectedLength;
    real randNum = uniform(0.0L, 1.0L);

    while(randNum > cutoff) {
        ret ~= uniform!"[]"('a', 'z');
        randNum = uniform(0.0L, 1.0L);
    }

    return ret;
}

void testPrint(T...)(T args) {
    stderr.writeln(args);
}

private void testIntegers() {
    // Test on random sparse integers.
    int[] keys;
    int[] values;
    RandAA!(int, int) intAA;

    foreach(i; 0..100_000) {
        auto num = uniform(0, int.max);
        intAA[num] = num * 2;
        keys ~= num;
        values ~= num * 2;
    }

    sort!"a[0] < b[0]"(zip(keys, values));
    foreach(i, k; keys) {
        enforce(intAA[k] == values[i],
            text(k, "  ", intAA[k], "  ", values[i]));
    }

    enforce(intAA.length == walkLength(uniq(keys)));

    auto k2 = intAA.keys;
    sort(k2);
    enforce(equal(k2, uniq(keys)));

    for(size_t i = 0; i < k2.length; i += 2) {
        enforce(intAA.remove(k2[i]) == k2[i] * 2);
    }

    foreach(i, k; k2) {
        if(i & 1) {
            enforce(intAA[k] == k * 2);
        } else {
            enforce(k !in intAA);
        }
    }

    enforce(intAA.length == k2.length - stride(k2, 2).length);

    // Test opIndexOpAssign stuff.
    intAA[1] = 1;
    intAA[1] += 2;
    enforce(intAA[1] == 3);
    intAA[1] -= 2;
    enforce(intAA[1] == 1);

    enforce(intAA.get(1, 0) == 1);
    intAA.remove(1);
    enforce(intAA.get(1, 0) == 0);

    testPrint("Passed integer tests.");
}

private void testStrings() {
    string[string] builtin;
    RandAA!(string, string) myAA;

    foreach(i; 0..100_000) {
        auto myKey = randString(20);
        auto myVal = randString(20);
        builtin[myKey] = myVal;
        myAA[myKey] = myVal;
    }

    enforce(myAA.length == builtin.length);
    foreach(key; myAA.keys) {
        enforce(myAA[key] == builtin[key]);
    }

    auto keys = builtin.keys;
    randomShuffle(keys);
    foreach(toRemove; keys[0..1000]) {
        builtin.remove(toRemove);
        myAA.remove(toRemove);
    }


    myAA.rehash();
    enforce(myAA.length == builtin.length);
    foreach(k, v; builtin) {
        enforce(k in myAA);
        enforce(myAA[k] == v);
    }

    string[] myValues;
    foreach(val; myAA.values) {
        myValues ~= val;
    }

    string[] myKeys;
    foreach(key; myAA.keys) {
        myKeys ~= key;
    }

    auto builtinKeys = builtin.keys;
    auto builtinVals = builtin.values;
    sort(builtinVals);
    sort(builtinKeys);
    sort(myKeys);
    sort(myValues);
    enforce(myKeys == builtinKeys);
    enforce(myValues == builtinVals);

    writeln("Passed string tests.");
}

private void stringSpeedTest(size_t nElem, uint nIter) {
    string[] strings = new string[nElem];

    foreach(ref s; strings) {
        s = randString(20);
    }

    real[2] doTimings(T)() {
        T myAA;
        static if(is(typeof(myAA.reserve(10)))) {
      //      myAA.reserve(1_000_000);
        }
        auto sw = StopWatch(AutoStart.yes);
        foreach(s; strings) {
            myAA[s] = s;
        }

        real[2] ret;
        ret[0] = sw.peek.msecs;

        foreach(s; strings) {
            auto v = myAA[s];
        }
        ret[1] = sw.peek.msecs - ret[0];
        return ret;
    }

    real[2] builtinTimings = 0;
    foreach(i; 0..nIter) {
        builtinTimings[]  += doTimings!(string[string])()[];
    }

    real[2] randTimings = 0;
    foreach(i; 0..nIter) {
        randTimings[] += doTimings!(RandAA!(string, string))()[];
    }

    writeln("Builtin:  Adding:  ", builtinTimings[0], "  Reading:  ",
        builtinTimings[1]);

    writeln("RandAA:  Adding:  ", randTimings[0], "  Reading:  ",
        randTimings[1]);
}

private void intSpeedTest(size_t nElem, uint nIter) {
    int[] ints = new int[nElem];

    foreach(ref i; ints) {
        i = uniform(0, int.max);
    }

    real[2] doTimings(T)() {
        T myAA;
        static if(is(typeof(myAA.reserve(10)))) {
      //      myAA.reserve(1_000_000);
        }
        auto sw = StopWatch(AutoStart.yes);
        foreach(i; ints) {
            myAA[i] = i;
        }

        real[2] ret;
        ret[0] = sw.peek.msecs;

        foreach(i; ints) {
            auto v = myAA[i];
        }
        ret[1] = sw.peek.msecs - ret[0];
        return ret;
    }

    real[2] builtinTimings = 0;
    foreach(i; 0..nIter) {
        builtinTimings[]  += doTimings!(int[int])()[];
    }

    real[2] randTimings = 0;
    foreach(i; 0..nIter) {
        randTimings[] += doTimings!(RandAA!(int, int))()[];
    }

    writeln("Builtin:  Adding:  ", builtinTimings[0], "  Reading:  ",
        builtinTimings[1]);

    writeln("RandAA:  Adding:  ", randTimings[0], "  Reading:  ",
        randTimings[1]);
}

void main() {
    testIntegers();
    testStrings();
    stringSpeedTest(1_000_000, 1);
    intSpeedTest(1_000_000, 1);

    // If this runs out of memory, the ref counting isn't working properly.
    foreach(i; 0..1_000) {
        RandAA!(uint, uint) aa;
        aa.reserve(1_000_000);
    }
}
